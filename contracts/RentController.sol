// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "./interfaces/IProperty.sol";
import "./interfaces/IRentController.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

// Uncomment this line to use console.log
// import "hardhat/console.sol";

contract RentController is IRentController {

    using EnumerableSet for EnumerableSet.Bytes32Set;

    /// @notice It is immutable because if all of a sudden this changes, 
    /// all balances are wrong for the new local currency.
    IERC20 immutable public local;

    /// d'accord ðŸ¥
    struct Accord {
        /// @notice the Accord Id is unique and it is generated by the slug.
        bytes32 id;

        /// Only three accounts are involved: owner, user, property.
        /// Should be immuble until -------
        address owner;
        address user;
        address property;

        /// @notice The most important dates in the Accord.
        uint64 startTimestamp;
        uint64 endTimestamp;

        /// 6 if 6 months, 12 if 12, and so on.
        uint8 dividedInto;
        uint256 rentAmount;

        /// Two currencies are needed.
        uint256 upfrontPaymentEth;
        uint256 upfrontPayment;

        /// -------

        /// @dev The accord balances should eventually go back to Zero.
        uint256 balanceEth;
        /// Of course `balance` is in `local` currency, as everything else.
        uint256 balance;

        bool approvedByUser;
        bool approvedByProperty;
    }

    // /// This mappings are HEAVY stuff, they should evenctually move off-chain.
    // mapping(address => bytes32[]) public accordOwners;
    // mapping(address => bytes32[]) public accordUser;
    // mapping(address => bytes32[]) public accordProperty;

    mapping(bytes32 => Accord) public accords;
    EnumerableSet.Bytes32Set private accordsHashIds;

    modifier onlyProperty(bytes32 _accordId) {
        Accord memory _accord = accords[_accordId];
        if (msg.sender != _accord.property) { revert Unauthorized(); }
        _;
    }

    constructor(IERC20 _localCurrency) {
        local = _localCurrency;
    }

    function getUniqueId(string memory _accordSlug) public view returns (bytes32) {
        bytes32 hash_id = keccak256(abi.encodePacked(_accordSlug));
        require(!accordsHashIds.contains(hash_id), "ACCORD_ID_ALREADY_EXISTS");
        return hash_id;
    }

    // /// @param _dividedInto 6 if 6 months, 12 if 12, and so on.
    // function proposeAccord(
    //     uint8 _dividedInto,
    //     uint64 _start,
    //     uint64 _end,
    //     uint256 _rentAmount,
    //     uint256 _upfrontPaymentEth,
    //     uint256 _upfrontPayment,
    //     IProperty _property,
    //     string memory _accordSlug
    // ) public {
    //     require(_dividedInto > 0);

    //     Accord memory _accord;
    //     bytes32 hash_id = getUniqueId(_accordSlug);
    //     _accord.id = hash_id;
    //     _accord.owner = msg.sender;

    //     /// If property is not available, next line will revert.
    //     _property.createReservation(msg.sender, hash_id, _start, _end);
    //     _accord.property = address(_property);

    //     _accord.startTimestamp = _start;
    //     _accord.endTimestamp = _end;
    //     _accord.rentAmount = _rentAmount;
    //     _accord.dividedInto = _dividedInto;
    //     _accord.upfrontPaymentEth = _upfrontPaymentEth;
    //     _accord.upfrontPayment = _upfrontPayment;

    //     accordsHashIds.add(hash_id);
    //     accordOwners[msg.sender].push(hash_id);
    //     accords[hash_id] = _accord;
    // }

    function confirmApprovedByProperty(bytes32 _accordId) public onlyProperty(_accordId) {
        Accord storage _accord = accords[_accordId];
        _accord.approvedByProperty = true;
    }
}