// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "./interfaces/IProperty.sol";
import "./interfaces/IRentController.sol";
import "./utils/Treasurable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";

// Uncomment this line to use console.log
// import "hardhat/console.sol";

contract RentController is IRentController, Treasurable {

    using EnumerableSet for EnumerableSet.Bytes32Set;
    using SafeERC20 for IERC20;

    /// @notice It is immutable because if all of a sudden this changes, 
    /// all balances are wrong for the new local currency.
    IERC20 immutable public local;

    /// Valid total balance in this contract.
    uint256 public totalBalance;
    uint256 public totalBalanceEth;

    /// d'accord 🥐
    struct AccordImmutable {

        /// 6 if 6 months, 12 if 12, and so on.
        uint8 dividedInto;

        /// @notice the Accord Id is unique and it is generated by the slug.
        bytes32 id;



        /// @notice The most important dates in the Accord.
        uint64 startTimestamp;
        uint64 endTimestamp;

        uint64 validUntil;


        uint256 rentAmount;

        /// Two currencies are needed.
        uint256 upfrontPaymentEth;
        uint256 upfrontPayment;

        /// Only three accounts are involved: owner, user, property.
        address owner;
        address user;
        IProperty property;
    }

    struct AccordMutable {
        /// @dev The accord balances should eventually go back to Zero.
        uint256 balanceEth;

        /// Of course `balance` is in `local` currency, as everything else.
        uint256 balance;

        bool approvedByUser;
        bool approvedByProperty;
    }

    // // /// This mappings are HEAVY stuff, they should evenctually move off-chain.
    // // mapping(address => bytes32[]) public accordOwners;
    // // mapping(address => bytes32[]) public accordUser;
    // // mapping(address => bytes32[]) public accordProperty;

    mapping(bytes32 => AccordImmutable) public accordsData;
    mapping(bytes32 => AccordMutable) public accords;
    
    /// @notice TODO: keep this growing with every new accord???
    EnumerableSet.Bytes32Set private accordsHashIds;

    modifier onlyProperty(bytes32 _accordId) {
        IProperty _property = accordsData[_accordId].property;
        if (msg.sender != address(_property)) { revert Unauthorized(); }
        _;
    }

    constructor(
        uint64 _createAccordPrice,
        uint64 _createAccordPriceEth,
        IERC20 _localCurrency
    ) Treasurable(_createAccordPrice, _createAccordPriceEth) {
        local = _localCurrency;
    }

    function getUniqueHashId(string memory _accordSlug) public view returns (bytes32) {
        bytes32 hash_id = keccak256(abi.encodePacked(_accordSlug));
        require(!accordsHashIds.contains(hash_id), "ACCORD_ID_ALREADY_EXISTS");
        return hash_id;
    }

    /// @param _dividedInto 6 if 6 months, 12 if 12, and so on.
    function proposeAccord(
        uint8 _dividedInto,
        uint64 _validUntil,
        uint64 _start,
        uint64 _end,
        uint256 _rentAmount,
        uint256 _upfrontPaymentEth,
        uint256 _upfrontPayment,
        IProperty _property,
        address _user,
        string memory _accordSlug
    ) public {
        require(_dividedInto > 0);

        AccordImmutable memory _data;
        bytes32 hash_id = getUniqueHashId(_accordSlug);
        _data.id = hash_id;
        _data.owner = msg.sender;

        /// If property is not available, next line will revert.
        _property.createReservation(msg.sender, hash_id, _validUntil, _start, _end);
        _data.property = _property;
        _data.user = _user;

        _data.startTimestamp = _start;
        _data.endTimestamp = _end;
        _data.validUntil = _validUntil;
        _data.rentAmount = _rentAmount;
        _data.dividedInto = _dividedInto;
        _data.upfrontPaymentEth = _upfrontPaymentEth;
        _data.upfrontPayment = _upfrontPayment;

        accordsHashIds.add(hash_id);
        // accordOwners[msg.sender].push(hash_id);
        accordsData[hash_id] = _data;
    }

    function confirmApprovedByProperty(bytes32 _accordId) public onlyProperty(_accordId) {
        AccordMutable storage _accord = accords[_accordId];
        _accord.approvedByProperty = true;
    }

    /// @param _amount denominated in local
    function acceptAccord(bytes32 _accordId, uint256 _amount) public payable {
        AccordImmutable memory _data = accordsData[_accordId];
        address _user = _data.user;
        require(block.timestamp < _data.validUntil);

        // address _user = accordsData[_accordId].user;
        AccordMutable memory _accord = accords[_accordId];
        if (msg.sender != _user) { revert Unauthorized(); }
        require(_accord.approvedByProperty);
        require(_amount >= _data.upfrontPayment);
        require(msg.value >= _data.upfrontPaymentEth);

        // The amounts for this values are initialized here
        _accord.balance = _amount;
        _accord.balanceEth = msg.value;
        _accord.approvedByUser = true;

        totalBalance += _amount;
        totalBalanceEth += msg.value;

        local.safeTransferFrom(msg.sender, address(this), _amount);
        _data.property.confirmedByUser(_accordId);
    }
}